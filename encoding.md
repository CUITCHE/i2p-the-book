# 编码[^1]

这里的编码（Encoding[^2]）当然不是指简单的编写代码。

为什么会有这个概念呢。

想想古老的印度人是怎么表示数字的吧：用十个不同的符号和位序组合来表示一个确切的数字，演化成今天我们的用阿拉伯数字（Arabic Numerials[^3]）表示的十进制系统。

没错就是你身边到处都存在的**数字**。这套系统只需要简单的十个符号和并不怎么复杂的规则就能从0表示到任意大的确切数字。

我们在第二讲中提到，代码中的int所表示的“整数”，跟数学意义上的整数，是有所差距的。这个差距其宗之一就在于表示数字的能力上。

比如，我们来计算$$2^{31}$$：
```c++
printf("%d", pow(2, 31));
```
嗯，输出了什么鬼（特别是`2147483648`前面那个符号）！

然后我们再试试计算$$2^{32}$$：
```c++
printf("%d", pow(2, 32));
```
嗯，更简单，结果直接变成0了。

也就是说，我们的int最大也就能表示到21亿多一点。随便找个大点的公司都不能拿他来记账。

为什么会这样呢？

## 二进制

跟阿拉伯数字系统一样，计算机内部也是利用位序来表示数值，但犹豫数字电路只有通和断两种状态，所以，相当于每位上只能有两种状态，作为传统，我们将用0和1来表示这两种状态。

然后我们就会看到计算机努力的表示数字：
$$0,1,10,11,100,101,110,111,1000,1001,1010$$
等你都觉得脑袋大了，计算机才数到10，不过其实关于这个问题并不需要你操心太多，反正跟阿拉伯数字一样，只要足够长，任意大的数都可以表示。

可是我们之前使用的过程告诉我们，其实并不是这样的。为什么呢？

### 定长

既然计算机表示数字就是靠0和1，那么如果我要表示多个数字，怎么来区分呢？

比如，你知道下面究竟是1，2，3，4还是13, 14？
```c++
11011100
```
于是其实我们可以思考一下，出了数值，还有什么可以利用的。

长度。

当我规定用于表示数据的长度必须是一定（比如4位）的时候，表示数据就特别地清晰了：
```c++
0001 0010 0011 0100
```
就可以表示1，2，3，4这四个数。而上面那个我们理解不了的序列，也可以解释成13，14这两个数。

当你去规定一种解释二进制序列的方法的时候，其实你就是在定义一种**编码**。

二进制序列中，每个0或者1，叫一个bit（位[^4]），特定长度（一般是8）的基本解释单位，叫做byte（字节[^5]），这个特定长度，据说是依据当前系统中表示基本的字符编码的长度来确定。

换句话说，编码不仅仅是能用来表示数字的。

## ASCII

现在提到字节大家都会反应是8位，就是因为这个东西。

全名叫American Standard Code for Information Interchange（美国标准信息交换码）。

这套代码从上世纪60年代一致用到现在，足以说明有多么经典。然而我们先不说他是什么，简单的从我们自己的角度出发先设计一套东西。

### 字符集

要知道美国人民的生活很是单调的，每天就面临大小写加起来四十多个字母，十个阿拉伯数字，以及十多个常用的标点符号。对比起来，我国人民可以享受用数万个。
