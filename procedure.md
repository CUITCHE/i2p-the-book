# 过程

什么是过程呢？

凭经验我们就能知道，实际的问题并不是像理想中那么简单，不是一个表达式就能描述的清楚的，而且也并不一定能通过组合来直接解决。

甚至是简单的数学问题，也不能用他们来解决。比如：
$$
\begin{eqnarray}
|x|
 = abs(x) = \begin{cases}
x, &x\ge0\cr
-x, &x\lt0\cr
\end{cases}
\end{eqnarray}
$$
求绝对值，
或者
$$pow(x,y) = \prod_{1}^{y}{x}$$
求和。

其中一个需要我们根据参数的值，来选择不同的计算方式，返回不同的结果；另外一个则是通过对特定的表达式做一个累乘（没错其实行为跟乘方是一样的，所以我把它叫pow[^1]）。

我们先看累乘。

## 累乘

如果我们已知指数的话，要写起来是很简单的：
```c++
int pow1(int x) { return x; }
int pow2(int x) { return pow1(x) * x; }
int pow3(int x) { return pow2(x) * x; }
...
int pow5(int x) { return pow4(x) * x; }
```
这样写其实是符合pow的定义的。

然后其实我们可以把它变换一下：
```c++
// 伪代码
int pow(int x, 1) { return x; }
int pow(int x, 2) { return pow(x, 1) * x; }
int pow(int x, 3) { return pow(x, 2) * x; }
...
int pow(int x, 5) { return pow(x, 4) * x; }
```
所以我们得到了pow函数的另一个形式：
$$
\begin{eqnarray}
pow(x, y) = \begin{cases}
x, &y=1\cr
pow(x, y -1)\times x, &y>1\cr
\end{cases}
\end{eqnarray}
$$
没错我们又归结到了选择结构上。后面我们会拿这个来讨论。现在只是简单提一提。

哦对了，现在pow的这个形式叫做递归[^2]定义，数学上叫递推关系式（好像又叫归纳[^3]定义？）。

好的，我们回到$$\sum$$运算符上来。

根据前面的分析，我们可以知道，如果能够拿到前面一个乘积，然后和第y个相乘，，就可以得到我们要的结果。

于是我们假设那第`y-1`个乘积是`prod`，最终的结果就是`prod*x`。再往前推`prod`，这个关系是基本上不变的。

那么，我们只要有一个东西来保存前面的结果，再跟后面的相乘之后更新保存的结果就可以了。

这个能保存数据的东西我们把它叫做变量（Variable）。

比如最开始`prod = 1`，然后`prod = prod * x`，会把`prod`与`x`相乘的结果计算出来，再保存进`prod`里面。

所以我们可以简单地把这个计算看成
```c++
int prod=1
prod=prod*x;
prod=prod*x;
prod=prod*x;
...
prod=prod*x; // 执行y次
```
那么怎么让他能够只执行`y`次呢？

## 循环

C++提供了一种东西叫做循环语句。

大概是长这个样子的
```c++
int prod=1;
for(int i = 1; i <= y; i = i+1) {
    prod = prod*x;
}
```
这个叫循环语句，意思就是，在满足指定条件的情况下，会一直去执行语句体（花括号之间）的内容。

上面那段代码的意思是，让`prod`初值为1，让`i`从1开始，每次增加1，如果`i`小于等于`y`的话，执行`prod = prod*x`，否则跳出循环。

确实很复杂，特别是比起上面那个递归定义来。

我们对它进行一个简单的改写。

一般来说，程序员是从0开始计数的。于是从`1～y`，就变成了从`0～y-1`，进一步地`i <= y-1`又可以进一步地写成`i < y`（反正都是整数，证明我就不给了），这样条件就简化掉了一个符号。

另外，但凡类似x=x+y这种的，都可以写成x+=y，特别地，当运算符为+和-，
